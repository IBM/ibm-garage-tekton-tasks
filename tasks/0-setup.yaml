apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-setup
  annotations:
    description: Sets up the pipeline environment and generates/normalizes a number of param values
    app.openshift.io/description: Sets up the pipeline environment and generates/normalizes a number of param values
    app.openshift.io/vcs-ref: master
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
  labels:
    version: 0.0.0
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-url
      default: ""
    - name: image-server
      default: ""
    - name: image-namespace
      default: ""
    - name: image-repository
      default: ""
    - name: image-tag
      default: ""
    - name: image-release
      default: ""
    - name: app-namespace
      default: ""
    - name: app-name
      default: ""
    - name: deploy-ingress-type
      default: "route"
    - name: health-protocol
      default: "https"
    - name: health-endpoint
      default: "/health"
    - name: tools-image
      default: garagecatalyst/ibmcloud-dev:1.1.3
    - name: js-image
      default: docker.io/node:lts-stretch
  results:
    - name: git-url
    - name: git-revision
    - name: image-url
    - name: image-server
    - name: image-namespace
    - name: image-repository
    - name: image-tag
    - name: image-release
    - name: app-namespace
    - name: app-name
    - name: deploy-ingress-type
    - name: health-protocol
    - name: health-endpoint
    - name: tools-image
    - name: js-image
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: alpine/git
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef: 
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef: 
              name: git-credentials
              key: username
              optional: true
        - name: REGISTRY_RELEASE_SERVER
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: REGISTRY_URL
              optional: true
        - name: REGISTRY_RELEASE_NAMESPACE
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: REGISTRY_NAMESPACE
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "https://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F 'https://' '{print $2}')" $(params.source-dir)
        else
            git clone $(params.git-url) $(params.source-dir)
        fi
        cd $(params.source-dir)
        git checkout $(params.git-revision)
        git reset --hard $(params.git-revision)

        # Results
        # Defaults
        echo -n "$(params.git-url)">$(results.git-url.path)
        echo -n "$(git rev-parse --verify HEAD)">$(results.git-revision.path)
        echo -n "$(params.app-namespace)">$(results.app-namespace.path)
        echo -n "$(params.app-name)">$(results.app-name.path)
        echo -n "$(params.deploy-ingress-type)">$(results.deploy-ingress-type.path)
        echo -n "$(params.health-protocol)">$(results.health-protocol.path)
        echo -n "$(params.health-endpoint)">$(results.health-endpoint.path)
        echo -n "$(params.tools-image)">$(results.tools-image.path)
        echo -n "$(params.js-image)">$(results.js-image.path)

        
        REGISTRY_SERVER="$(params.image-server)"
        REGISTRY_NAMESPACE="$(params.image-namespace)"
        REGISTRY_REPOSITORY="$(params.image-repository)"
        REGISTRY_TAG="$(params.image-tag)"

        if [[ -n "$(params.image-url)" ]]; then
          REGISTRY_SERVER_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $1}')
          if [[ -n "${REGISTRY_SERVER_VALUE}" ]]; then
            REGISTRY_SERVER="${REGISTRY_SERVER_VALUE}"
          fi

          REGISTRY_NAMESPACE_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $2}')
          if [[ -n "${REGISTRY_NAMESPACE_VALUE}" ]]; then
            if [[ "${REGISTRY_NAMESPACE_VALUE}" = '$NAMESPACE' ]]; then
              REGISTRY_NAMESPACE=${NAMESPACE}
            else
              REGISTRY_NAMESPACE="${REGISTRY_NAMESPACE_VALUE}"
            fi
          fi

          REGISTRY_REPOSITORY_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $3}')
          if [[ -n "${REGISTRY_REPOSITORY_VALUE}" ]]; then
            REGISTRY_REPOSITORY="${REGISTRY_REPOSITORY_VALUE}"
          fi

          REGISTRY_TAG_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $2}' | awk -F : '{print $2}')
          if [[ -n "${REGISTRY_TAG_VALUE}" ]]; then
            REGISTRY_TAG="${REGISTRY_TAG_VALUE}"
          fi
        fi

        if [[ -z "${REGISTRY_SERVER}" ]]; then
          # Assume is internal
          REGISTRY_SERVER="image-registry.openshift-image-registry.svc:5000"
        fi
        if [[ -z "${REGISTRY_NAMESPACE}" ]]; then
          # Assume current k8s namespace
          REGISTRY_NAMESPACE="${NAMESPACE}"
        fi
        if [[ -z "${REGISTRY_REPOSITORY}" ]]; then
          # Assume repo dir is image repository/image-name
          REGISTRY_REPOSITORY="$(basename $(echo -n $(git config --get remote.origin.url) | awk -F '.git' '{print $2}') | tr '[:upper:]' '[:lower:]' | sed 's/_/-/g')"
        fi
        if [[ -z "${REGISTRY_TAG}" ]]; then
          # Assume short git commit revision
          REGISTRY_TAG="$(git rev-parse --verify HEAD --short)"
        fi
        echo -n "${REGISTRY_SERVER}">$(results.image-server.path)
        echo -n "${REGISTRY_NAMESPACE}">$(results.image-namespace.path)
        echo -n "${REGISTRY_REPOSITORY}">$(results.image-repository.path)
        echo -n "${REGISTRY_TAG}">$(results.image-tag.path)
        echo -n "${REGISTRY_SERVER}/${REGISTRY_NAMESPACE}/${REGISTRY_REPOSITORY}:${REGISTRY_TAG}">$(results.image-url.path)


        if [[ -z "$(params.app-namespace)" ]]; then
          # Assume current namespace
          echo -n "${NAMESPACE}">$(results.app-namespace.path)
        fi

        if [[ -z "$(params.app-name)" ]]; then
          # Assume image repository/name
          echo -n "${REGISTRY_REPOSITORY}">$(results.app-name.path)
        fi

      
        if [[ -n "$(params.image-release)" ]]; then
          REGISTRY_RELEASE_SERVER_VALUE=$(echo "$(params.image-release)" | awk -F / '{print $1}')
          if [[ -n "${REGISTRY_RELEASE_SERVER_VALUE}" ]]; then
            REGISTRY_RELEASE_SERVER="${REGISTRY_RELEASE_SERVER_VALUE}"
          fi

          REGISTRY_RELEASE_NAMESPACE_VALUE=$(echo "$(params.image-release)" | awk -F / '{print $2}')
          if [[ -n "${REGISTRY_RELEASE_NAMESPACE_VALUE}" ]]; then
            if [[ "${REGISTRY_RELEASE_NAMESPACE_VALUE}" = '$NAMESPACE' ]]; then
              REGISTRY_RELEASE_NAMESPACE=${NAMESPACE}
            else
              REGISTRY_RELEASE_NAMESPACE="${REGISTRY_RELEASE_NAMESPACE_VALUE}"
            fi
          elif [[ "${REGISTRY_RELEASE_SERVER}" = "image-registry.openshift-image-registry.svc:5000" ]]; then
            REGISTRY_RELEASE_NAMESPACE=${NAMESPACE}
          fi
        fi
        if [[ -z "${REGISTRY_RELEASE_NAMESPACE}" ]]; then
          # Assume current k8s namespace
          REGISTRY_RELEASE_NAMESPACE="${NAMESPACE}"
        fi
        REGISTRY_RELEASE_URL="${REGISTRY_RELEASE_SERVER}/${REGISTRY_RELEASE_NAMESPACE}/${REGISTRY_REPOSITORY}"
        echo -n "${REGISTRY_RELEASE_URL}">$(results.image-release.path)
        for f in /tekton/results/*; do echo "results.$(basename $f)=$(cat $f)"; done




